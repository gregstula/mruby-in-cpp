// Copyright Â© 2016 Gregory D. Stula. All rights reserved.
#include <cstdint>
#include "mruby.h"
#include "mruby/irep.h"

class mruby_state {
public:
    mruby_state(); 
    ~mruby_state();
    
    void load(const uint8_t
#if defined __GNUC__
              __attribute__((aligned(4)))
#elif defined _MSC_VER
              __declspec(align(4))
#endif
    bytes[]);

private:
    mrb_state* _state;
};

mruby_state::mruby_state() {
    _state = mrb_open();
    if (!_state) {
        throw 9999;
    }
}

mruby_state::~mruby_state() {
    mrb_close(_state);
}

void mruby_state::load(const uint8_t bytes[]) {
    mrb_load_irep(_state, bytes);
}

/* dumped in little endian order.
   use `mrbc -E` option for big endian CPU. */
const uint8_t

#if defined __GNUC__
    __attribute__((aligned(4)))
#elif defined _MSC_VER
    __declspec(align(4))
#endif
bytecode[] = {
0x45,0x54,0x49,0x52,0x30,0x30,0x30,0x33,0x73,0x0d,0x00,0x00,0x00,0x65,0x4d,0x41,
0x54,0x5a,0x30,0x30,0x30,0x30,0x49,0x52,0x45,0x50,0x00,0x00,0x00,0x47,0x30,0x30,
0x30,0x30,0x00,0x00,0x00,0x3f,0x00,0x01,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x04,
0x06,0x00,0x80,0x00,0x3d,0x00,0x00,0x01,0xa0,0x00,0x80,0x00,0x4a,0x00,0x00,0x00,
0x00,0x00,0x00,0x01,0x00,0x00,0x0b,0x68,0x65,0x6c,0x6c,0x6f,0x20,0x77,0x6f,0x72,
0x6c,0x64,0x00,0x00,0x00,0x01,0x00,0x04,0x70,0x75,0x74,0x73,0x00,0x45,0x4e,0x44,
0x00,0x00,0x00,0x00,0x08,
};

int
main(void)
{
  mruby_state mrb = mrb_open();
  mrb.load(bytecode);
}


